TCP拆包/粘包
由于TCP是面向流的，所以加入我们从客户端向服务器发送两个数据包D1和D2，此时可能有如下几种情况
1、服务器分别收到了两个数据包D1\D2此时没有发生粘包、拆包
2、服务器第一次收到了D1的数据包和D2的一部分，此时发生了粘包，需要拆包
3、服务器一次性收到了D1和D2，此时发生了粘包，需要拆包
4、服务器第一次收到了D1的一部分，第二次收到了D1剩下的部分和D2的全部

补充知识
MTU: Maxitum Transmission Unit 最大传输单元(1500Bytes)
MSS: Maxitum Segment Size MSS就是TCP数据包每次能够传输的最大数据分段。为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以往往MSS为1460。通讯双方会根据双方提供的MSS值得最小值确定为这次连接的最大MSS值。

发生的原因
1、应用程序发送的数据大于缓冲区大小，需要多次冲刷缓冲区
2、虽然缓冲区够用，MMS小了，需要进行分段
3、MMS够了，但是MTU小了，需要进行IP分片

解决粘包、拆包的方法
很明显拆包的发生是由于发送方发送的数据包太大导致的，而粘包则是由于两个逻辑上独立的数据包被TCP流式传输粘在一起了
这个时候需要一种机制用以应对在发生这种情况时能够明确数据包之间的边界。
1、包定长，通讯双方规定每个数据包的大小。
2、头部携带内容长度字段
3、使用分隔符

netty就很贴心了，准备了几个内置的解码器用来应对这种情况，还准备了可以给你扩展的自定义解码器可以自定义分隔符去解决粘包拆包